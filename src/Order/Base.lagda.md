```agda
open import Cat.Displayed.Univalence.Thin
open import Cat.Prelude

module Order.Base where
```

# Partially ordered sets

A **poset** (short for **p**artially **o**rdered set) is a \r{set}
equipped with a relation $x \le y$ which is reflexive, transitive and
antisymmetric. Put another way, a poset is a [univalent] \r{category}
having at most one morphism between each pair of elements.

For convenience reasons, we prefer _not_ to work with the category
generated by a poset: the category associated with a poset reifies a lot
of _redundant_ information, which is necessary when working with
$\hom$-sets, but not with $\hom$-props. Working with the generated
category is analogous to only ever working with locally discrete
bicategories: you _could_, but then you'd be hauling around a bunch of
redundant information.

[univalent]: Cat.Univalent.html

Another reason to define posets as their own concept, rather than as a
special case of categories, is using our pre-existing infrastructure for
constructing very convenient categories of sets-with-structure; In this
case, sets with "po" structure!

We start by defining the _predicate_ `is-partial-order`{.Agda} on a
relation $x \le y$. That it turns out to be a predicate is actually
slightly nontrivial: The first four components are manifestly
propositional, but the last component --- the witness of antisymmetry
--- could really gunk things up, since it has the potential to assign
loops! But, given any antisymmetric relation $x \le y$, the family

$$
(x, y) \mapsto (x \le y) \land (y \le x)
$$

is an identity system^[Together with the unique evidence that this is a
reflexive relation] on $A$; and, being a product of propositions, it's
also a proposition, so $A$ is automatically a set.

```agda
record is-partial-order {ℓ ℓ′} {A : Type ℓ}
          (_≤_ : A → A → Type ℓ′) : Type (ℓ ⊔ ℓ′) where
  no-eta-equality
  field
    ≤-thin    : ∀ {x y} → is-prop (x ≤ y)
    ≤-refl    : ∀ {x} → x ≤ x
    ≤-trans   : ∀ {x y z} → x ≤ y → y ≤ z → x ≤ z
    ≤-antisym : ∀ {x y} → x ≤ y → y ≤ x → x ≡ y

  has-is-set : is-set A
  has-is-set =
    identity-system→hlevel 1
      {r = λ _ → ≤-refl , ≤-refl}
      (set-identity-system
        (λ a b → ×-is-hlevel 1 ≤-thin ≤-thin)
        (λ {a} {b} (p , q) → ≤-antisym {a} {b} p q))
      (λ a b → ×-is-hlevel 1 ≤-thin ≤-thin)
```

<!--
```agda
private unquoteDecl eqv = declare-record-iso eqv (quote is-partial-order)

is-partial-order-is-prop
  : ∀ {ℓ ℓ′} {A : Type ℓ} (R : A → A → Type ℓ′) → is-prop (is-partial-order R)
is-partial-order-is-prop {A = A} R x y = go x x y where
  go : is-partial-order R → is-prop (is-partial-order R)
  go x = Iso→is-hlevel 1 eqv (hlevel 1) where instance
    h-level-r : ∀ {x y} {n} → H-Level (R x y) (suc n)
    h-level-r = prop-instance (x .is-partial-order.≤-thin)

    h-level-a : H-Level A 2
    h-level-a = basic-instance 2 (is-partial-order.has-is-set x)
```
-->

A po structure on a set --- okay, that joke _is_ getting old --- is
given by tupling together the relation $x \le y$ together with a proof
that it is a partial order relation. Identity of poset structures is
thus determined by identity _of the relations_, since being a partial
order is a proposition.

```agda
record Poset-on {ℓ} ℓ′ (A : Type ℓ) : Type (ℓ ⊔ lsuc ℓ′) where
  no-eta-equality
  field
    _≤_          : A → A → Type ℓ′
    has-is-poset : is-partial-order _≤_
  open is-partial-order has-is-poset public
```

We set up the category of posets using our [machinery for displaying]
[univalent categories] over the category of sets. A map between posets
is called a **monotone map**: it's the decategorification of a functor.
We don't need preservation of identities _or_ preservation of
composites, since our "homs" are propositions!

[machinery for displaying]: Cat.Displayed.Univalence.Thin.html
[univalent categories]: Cat.Univalent.html

```agda
Poset-structure : ∀ ℓ ℓ′ → Thin-structure {ℓ = ℓ} (ℓ ⊔ ℓ′) (Poset-on ℓ′)
∣ Poset-structure ℓ ℓ′ .is-hom f P Q ∣ =
  ∀ x y → Poset-on._≤_ P x y → Poset-on._≤_ Q (f x) (f y)

Poset-structure ℓ ℓ′ .is-hom f P Q .is-tr =
  Π-is-hlevel³ 1 λ _ _ _ → Poset-on.≤-thin Q

Poset-structure ℓ ℓ′ .id-is-hom x y α = α
Poset-structure ℓ ℓ′ .∘-is-hom f g α β x y γ = α (g x) (g y) (β x y γ)
```

The last thing we have to prove is "uniqueness of identity maps": If we
have the identity being a monotone map $(a, t) \to (a, s)$ _and_ $(a, s)
\to (a, t)$ --- that is, we have $(x \le_s y) \leftrightarrow (x \le_t
y)$ --- then, by propositional extensionality, we have $\le_s = \le_t$.
Then, since equality of poset structures is controlled by equality of
the relations, we have $s = t$!

```agda
Poset-structure ℓ ℓ′ .id-hom-unique {s = s} {t = t} α β = q where
  module s = Poset-on s
  module t = Poset-on t
  open is-iso

  p : s._≤_ ≡ t._≤_
  p i x y = ua (prop-ext s.≤-thin t.≤-thin (α x y) (β x y)) i

  q : s ≡ t
  q i .Poset-on._≤_ = p i
  q i .Poset-on.has-is-poset = is-prop→pathp
    (λ i → is-partial-order-is-prop (p i))
    s.has-is-poset t.has-is-poset i
```

<!--
```agda
Posets : ∀ ℓ ℓ′ → Precategory (lsuc (ℓ ⊔ ℓ′)) (ℓ ⊔ ℓ′)
Posets ℓ ℓ′ = Structured-objects (Poset-structure ℓ ℓ′)

module Posets {ℓ ℓ′} = Precategory (Posets ℓ ℓ′)
Poset : (ℓ ℓ′ : Level) → Type (lsuc (ℓ ⊔ ℓ′))
Poset ℓ ℓ′ = Precategory.Ob (Posets ℓ ℓ′)

record make-poset {ℓ} ℓ′ (A : Type ℓ) : Type (ℓ ⊔ lsuc ℓ′) where
  no-eta-equality

  field
    rel     : A → A → Type ℓ′
    id      : ∀ {x} → rel x x
    thin    : ∀ {x y} → is-prop (rel x y)
    trans   : ∀ {x y z} → rel x y → rel y z → rel x z
    antisym : ∀ {x y} → rel x y → rel y x → x ≡ y

  to-poset-on : Poset-on ℓ′ A
  to-poset-on .Poset-on._≤_ = rel
  to-poset-on .Poset-on.has-is-poset .is-partial-order.≤-thin = thin
  to-poset-on .Poset-on.has-is-poset .is-partial-order.≤-refl = id
  to-poset-on .Poset-on.has-is-poset .is-partial-order.≤-trans = trans
  to-poset-on .Poset-on.has-is-poset .is-partial-order.≤-antisym = antisym

to-poset : ∀ {ℓ ℓ′} (A : Type ℓ) → make-poset ℓ′ A → Poset ℓ ℓ′
∣ to-poset A mk .fst ∣ = A
to-poset A mk .fst .is-tr = Poset-on.has-is-set (make-poset.to-poset-on mk)
to-poset A mk .snd = make-poset.to-poset-on mk
```
-->

The relationship between posets and (strict) categories is outlined in
the module [`Order.Cat`](Order.Cat.html). Very similarly to
categories, posets have a duality involution. In fact, under the
correspondence between posets and thin categories, these are the same
construction.

```agda
_^opp : ∀ {ℓ ℓ′} → Poset ℓ ℓ′ → Poset ℓ ℓ′
P ^opp = to-poset ⌞ P ⌟ mk-opp where
  open Poset-on (P .snd)
  mk-opp : make-poset _ _
  mk-opp .make-poset.rel x y         = y ≤ x
  mk-opp .make-poset.thin            = ≤-thin
  mk-opp .make-poset.id              = ≤-refl
  mk-opp .make-poset.trans f<g g<h   = ≤-trans g<h f<g
  mk-opp .make-poset.antisym f<g g<f = ≤-antisym g<f f<g
```

## Monotone maps

The **monotone map** is the posetal analogue of a functor: A function
between the underlying sets which preserves the order relation. Note
that since a partial order is a proposition, we do not need to concern
ourselves with functoriality! This is a special case of the [pointwise
ordering], but it gets its own definition for two reasons:

1. The conceptual importance of monotone maps. They simply come up in
more constructions than arbitrary pointwise orders. As an example, take
[lower sets]

2. Proof assistants are evil software overlords we have to cater to.

[pointwise ordering]: Order.Instances.Pointwise.html
[lower sets]: Order.Instances.Lower.html

```agda
record Monotone-map {ℓₒ ℓᵣ ℓₒ′ ℓᵣ′} (P : Poset ℓₒ ℓᵣ) (Q : Poset ℓₒ′ ℓᵣ′) : Type (ℓₒ ⊔ ℓₒ′ ⊔ ℓᵣ ⊔ ℓᵣ′) where
  no-eta-equality
  private
    module P = Poset-on (P .snd)
    module Q = Poset-on (Q .snd)

  field
    map      : ⌞ P ⌟ → ⌞ Q ⌟
    monotone : ∀ {x y} → x P.≤ y → map x Q.≤ map y

open Monotone-map public

private unquoteDecl eqv′ = declare-record-iso eqv′ (quote Monotone-map)

Monotone : ∀ {ℓₒ ℓᵣ ℓₒ′ ℓᵣ′} (P : Poset ℓₒ ℓᵣ) (Q : Poset ℓₒ′ ℓᵣ′) → Poset _ _
∣ Monotone P Q .fst ∣ = Monotone-map P Q

Monotone P Q .fst .is-tr = Iso→is-hlevel 2 eqv′ $
  Σ-is-hlevel 2 (fun-is-hlevel 2 (Q .fst .is-tr)) λ map →
    is-prop→is-set $
      Π-is-hlevel′ 1 λ x → Π-is-hlevel′ 1 λ y →
        fun-is-hlevel 1 (Poset-on.≤-thin (Q .snd))

Monotone P Q .snd = make-poset.to-poset-on mk where
  module Q = Poset-on (Q .snd)

  open make-poset
  mk : make-poset _ _
  mk .rel F G = ∀ x → F .map x Q.≤ G .map x
  mk .id x = Q.≤-refl
  mk .thin = Π-is-hlevel 1 λ _ → Q.≤-thin
  mk .trans f g x = Q.≤-trans (f x) (g x)
  mk .antisym f g i .map x = Q.≤-antisym (f x) (g x) i
  mk .antisym {x = x} {y = y} f g i .monotone x≤y =
    is-prop→pathp (λ i → Q.≤-thin {Q.≤-antisym (f _) (g _) i} {Q.≤-antisym (f _) (g _) i})
      (x .monotone x≤y) (y .monotone x≤y) i
```

<!--
```agda
Monotone-pathp
  : ∀ {ℓₒ ℓᵣ ℓₒ′ ℓᵣ′} (P : I → Poset ℓₒ ℓᵣ) (Q : I → Poset ℓₒ′ ℓᵣ′)
  → {x : Monotone-map (P i0) (Q i0)} {y : Monotone-map (P i1) (Q i1)}
  → PathP (λ i → ⌞ P i ⌟ → ⌞ Q i ⌟) (x .map) (y .map)
  → PathP (λ i → Monotone-map (P i) (Q i)) x y
Monotone-pathp P Q {x = x} {y} p i .map = p i
Monotone-pathp P Q {x = x} {y} p i .monotone {a} {b} arg =
  is-prop→pathp
    (λ i → Π-is-hlevel³ {C = λ x y → P i .snd .Poset-on._≤_ x y} 1
      λ a b c → Q i .snd .Poset-on.≤-thin {p i a} {p i b})
    (λ _ _ → x .monotone) (λ _ _ → y .monotone) i a b arg

Monotone-path
  : ∀ {ℓₒ ℓᵣ ℓₒ′ ℓᵣ′} {P : Poset ℓₒ ℓᵣ} {Q : Poset ℓₒ′ ℓᵣ′}
  → {x y : Monotone-map P Q}
  → (∀ a → x .map a ≡ y .map a)
  → x ≡ y
Monotone-path {P = P} {Q} path = Monotone-pathp (λ _ → P) (λ _ → Q) (funext path)
```
-->
