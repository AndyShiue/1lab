<!--
```agda
open import Cat.Prelude

import Cat.Reasoning
```
-->

```agda
module Order.Base where
```

# Partially ordered sets {defines="poset partial-order partially-ordered-set"}

A **poset** (short for **p**artially **o**rdered set) is a [[set]]
equipped with a relation $x \le y$ which is reflexive, transitive and
antisymmetric. Put another way, a poset is a [[univalent category]],
which additionally satisfies the property that there is _at most one_
morphism inhabiting each $\hom$-set.

For convenience reasons, we prefer _not_ to work with the category
generated by a poset: the category associated with a poset reifies a lot
of _redundant_ information, which is necessary when working with
$\hom$-sets, but not with $\hom$-props. Working with the generated
category is analogous to only ever working with locally discrete
bicategories: you _could_, but then you'd be hauling around a bunch of
redundant information.

[univalent]: Cat.Univalent.html

Another reason to define posets as their own concept, rather than as a
special case of categories, is using our pre-existing infrastructure for
constructing very convenient categories of sets-with-structure; In this
case, sets with "po" structure!

We start by defining the _predicate_ `is-partial-order`{.Agda} on a
relation $x \le y$. That it turns out to be a predicate is actually
slightly nontrivial: The first four components are manifestly
propositional, but the last component --- the witness of antisymmetry
--- could really gunk things up, since it has the potential to assign
loops! But, given any antisymmetric relation $x \le y$, the family

$$
(x, y) \mapsto (x \le y) \land (y \le x)
$$

is an [[identity system]]^[Together with the unique evidence that this is a
reflexive relation] on $A$; and, being a product of propositions, it's
also a proposition, so $A$ is automatically a set.

```agda
record is-partial-order {ℓ ℓ′} {A : Type ℓ}
          (_≤_ : A → A → Type ℓ′) : Type (ℓ ⊔ ℓ′) where
  no-eta-equality
  field
    ≤-thin    : ∀ {x y} → is-prop (x ≤ y)
    ≤-refl    : ∀ {x} → x ≤ x
    ≤-trans   : ∀ {x y z} → x ≤ y → y ≤ z → x ≤ z
    ≤-antisym : ∀ {x y} → x ≤ y → y ≤ x → x ≡ y

  opaque
    has-is-set : is-set A
    has-is-set =
      identity-system→hlevel 1
        {r = λ _ → ≤-refl , ≤-refl}
        (set-identity-system
          (λ a b → ×-is-hlevel 1 ≤-thin ≤-thin)
          (λ {a} {b} (p , q) → ≤-antisym {a} {b} p q))
        (λ a b → ×-is-hlevel 1 ≤-thin ≤-thin)
```

<!--
```agda
private unquoteDecl eqv = declare-record-iso eqv (quote is-partial-order)

is-partial-order-is-prop
  : ∀ {ℓ ℓ′} {A : Type ℓ} (R : A → A → Type ℓ′) → is-prop (is-partial-order R)
is-partial-order-is-prop {A = A} R x y = go x x y where
  go : is-partial-order R → is-prop (is-partial-order R)
  go x = Iso→is-hlevel 1 eqv (hlevel 1) where instance
    h-level-r : ∀ {x y} {n} → H-Level (R x y) (suc n)
    h-level-r = prop-instance (x .is-partial-order.≤-thin)

    h-level-a : H-Level A 2
    h-level-a = basic-instance 2 (is-partial-order.has-is-set x)
```
-->

A po structure on a set --- okay, that joke _is_ getting old --- is
given by tupling together the relation $x \le y$ together with a proof
that it is a partial order relation. Identity of poset structures is
thus determined by identity _of the relations_, since being a partial
order is a proposition.

```agda
record Poset-on {ℓ} ℓ′ (A : Type ℓ) : Type (ℓ ⊔ lsuc ℓ′) where
  no-eta-equality
  field
    _≤_          : A → A → Type ℓ′
    has-is-poset : is-partial-order _≤_
  open is-partial-order has-is-poset public
```

<!--
```agda
Poset-on-pathp
  : ∀ {o ℓ} {A B : Type o}
  → {A-poset : Poset-on ℓ A} {B-poset : Poset-on ℓ B}
  → (p : A ≡ B)
  → PathP (λ i → p i → p i → Type ℓ) (Poset-on._≤_ A-poset) (Poset-on._≤_ B-poset)
  → PathP (λ i → Poset-on ℓ (p i)) A-poset B-poset
Poset-on-pathp p q i .Poset-on._≤_ = q i
Poset-on-pathp {A-poset = A-poset} {B-poset = B-poset} p q i .Poset-on.has-is-poset =
  is-prop→pathp (λ i → is-partial-order-is-prop (q i))
    (Poset-on.has-is-poset A-poset)
    (Poset-on.has-is-poset B-poset) i

Poset-on-path
  : ∀ {o ℓ} {A : Type o}
  → {P Q : Poset-on ℓ A}
  → (∀ x y → Poset-on._≤_ P x y ≡ Poset-on._≤_ Q x y)
  → P ≡ Q
Poset-on-path p = Poset-on-pathp refl (funext λ x → funext λ y → p x y)

record Poset o ℓ : Type (lsuc (o ⊔ ℓ)) where
  field
    Ob       : Type o
    poset    : Poset-on ℓ Ob
  open Poset-on poset public

instance
  Underlying-Poset : ∀ {o ℓ} → Underlying (Poset o ℓ)
  Underlying-Poset = record { ⌞_⌟ = Poset.Ob }
```
-->

We set up the category of posets using our [machinery for displaying]
[univalent categories] over the category of sets. A map between posets
is called a **monotone map**: it's the decategorification of a functor.
We don't need preservation of identities _or_ preservation of
composites, since our "homs" are propositions!

[machinery for displaying]: Cat.Displayed.Univalence.Thin.html
[univalent categories]: Cat.Univalent.html

```agda
is-monotone
  : ∀ {o o' ℓ ℓ'} {A : Type o} {B : Type o'}
  → (f : A → B) → Poset-on ℓ A → Poset-on ℓ' B → Type _
is-monotone f P Q = ∀ {x y} → x P.≤ y → f x Q.≤ f y where
  module P = Poset-on P
  module Q = Poset-on Q

is-monotone-is-prop
  : ∀ {o o' ℓ ℓ'} {A : Type o} {B : Type o'}
  → (f : A → B) (P : Poset-on ℓ A) (Q : Poset-on ℓ' B)
  → is-prop (is-monotone f P Q)
is-monotone-is-prop f P Q =
  Π-is-hlevel′ 1 λ _ →
  Π-is-hlevel′ 1 λ _ →
  fun-is-hlevel 1 (Poset-on.≤-thin Q)

record Monotone {o ℓ o′ ℓ′} (P : Poset o ℓ) (Q : Poset o′ ℓ′) : Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) where
  field
    hom  : ⌞ P ⌟ → ⌞ Q ⌟
    pres : is-monotone hom (P .Poset.poset) (Q .Poset.poset)
```

<!--
```agda
open Monotone public

Monotone-pathp
  : ∀ {o ℓ o′ ℓ′}
  → (P : I → Poset o ℓ) (Q : I → Poset o′ ℓ′)
  → {f : Monotone (P i0) (Q i0)} {g : Monotone (P i1) (Q i1)}
  → (p : PathP (λ i → ⌞ P i ⌟ → ⌞ Q i ⌟) (f .hom) (g .hom))
  → PathP (λ i → Monotone (P i) (Q i)) f g
Monotone-pathp P Q {f} {g} p i .hom = p i
Monotone-pathp P Q {f} {g} p i .pres =
  is-prop→pathp
    (λ i → is-monotone-is-prop (p i) (P i .Poset.poset) (Q i .Poset.poset))
    (f .pres) (g .pres) i

instance
  Funlike-Monotone : ∀ {o ℓ o′ ℓ′} → Funlike (Monotone {o} {ℓ} {o′} {ℓ′})
  Funlike-Monotone = record
    { _#_ = hom
    ; ext = λ x → Monotone-pathp _ _ (funext x)
    }

module _ where
  private variable
    o ℓ o′ ℓ′ : Level
    P Q R : Poset o ℓ

  Idᵐ : Monotone P P
  Idᵐ .hom x = x
  Idᵐ .pres α = α

  _∘ᵐ_ : Monotone Q R → Monotone P Q → Monotone P R
  _∘ᵐ_ f g .hom x  = f # (g # x)
  _∘ᵐ_ f g .pres α = f .pres (g .pres α)

  instance
    H-Level-Monotone : ∀ {n} → H-Level (Monotone P Q) (2 + n)
    H-Level-Monotone {P = P} {Q = Q} {n = n} = basic-instance 2 $ Iso→is-hlevel 2 eqv' $
      Σ-is-hlevel 2
        (fun-is-hlevel 2 (Poset.has-is-set Q))
        λ f → is-prop→is-set (is-monotone-is-prop f (P .Poset.poset) (Q .Poset.poset))
      where
      private unquoteDecl eqv' = declare-record-iso eqv' (quote Monotone)

  Monotone-path : {f g : Monotone P Q} → (∀ x → f .hom x ≡ g .hom x) → f ≡ g
  Monotone-path p = Monotone-pathp _ _ (funext p)


module _ where
  open Precategory
```
-->

```agda
  Posets : ∀ o ℓ → Precategory (lsuc (o ⊔ ℓ)) (o ⊔ ℓ)
  Posets o ℓ .Ob  = Poset o ℓ
  Posets o ℓ .Hom = Monotone
  Posets o ℓ .Hom-set x y = hlevel 2
  Posets o ℓ .id = Idᵐ
  Posets o ℓ ._∘_ = _∘ᵐ_
  Posets o ℓ .idr f = Monotone-path λ _ → refl
  Posets o ℓ .idl f = Monotone-path λ _ → refl
  Posets o ℓ .assoc f g h = Monotone-path λ _ → refl

module Posets {o} {ℓ} = Cat.Reasoning (Posets o ℓ)
```

```agda
Posets-is-category : ∀ {o ℓ} → is-category (Posets o ℓ)
Posets-is-category .to-path {a} {b} p = q module Poset-path where
  open Poset
  open Poset-on

  Ob-equiv : Iso (a .Ob) (b .Ob)
  Ob-equiv .fst = apply (Posets.to p)
  Ob-equiv .snd = iso (apply (Posets.from p)) (λ x → Posets.invl p #ₚ x) (λ x → Posets.invr p #ₚ x)

  Ob-path : a .Ob ≡ b .Ob
  Ob-path = Iso→Path Ob-equiv

  opaque
    ≤-path : PathP (λ i → Ob-path i → Ob-path i → Type _) (a .Poset._≤_) (b .Poset._≤_)
    ≤-path = ua→2 λ x y → ua $ prop-ext (Poset.≤-thin a) (Poset.≤-thin b)
      (Posets.to p .pres)
      λ α → transport (ap₂ (Poset._≤_ a) (Posets.invr p #ₚ x) (Posets.invr p #ₚ y))
              (Posets.from p .pres α)

  q : a ≡ b
  q i .Ob = Ob-path i
  q i .poset ._≤_ = ≤-path i
  q i .poset .has-is-poset = is-prop→pathp
    (λ i → is-partial-order-is-prop (≤-path i))
    (a .poset .has-is-poset) (b .poset .has-is-poset) i
Posets-is-category .to-path-over p = Posets.≅-pathp _ _ $ Monotone-pathp _ _ $
  funextP λ a → path→ua-pathp (Iso→Equiv (Poset-path.Ob-equiv p)) refl
```

<!--
```agda
record make-poset {ℓ} ℓ′ (A : Type ℓ) : Type (ℓ ⊔ lsuc ℓ′) where
  no-eta-equality

  field
    rel     : A → A → Type ℓ′
    id      : ∀ {x} → rel x x
    thin    : ∀ {x y} → is-prop (rel x y)
    trans   : ∀ {x y z} → rel x y → rel y z → rel x z
    antisym : ∀ {x y} → rel x y → rel y x → x ≡ y

  to-poset-on : Poset-on ℓ′ A
  to-poset-on .Poset-on._≤_ = rel
  to-poset-on .Poset-on.has-is-poset .is-partial-order.≤-thin = thin
  to-poset-on .Poset-on.has-is-poset .is-partial-order.≤-refl = id
  to-poset-on .Poset-on.has-is-poset .is-partial-order.≤-trans = trans
  to-poset-on .Poset-on.has-is-poset .is-partial-order.≤-antisym = antisym

to-poset : ∀ {ℓ ℓ′} (A : Type ℓ) → make-poset ℓ′ A → Poset ℓ ℓ′
to-poset A mk .Poset.Ob    = A
to-poset A mk .Poset.poset = make-poset.to-poset-on mk
```
-->

The relationship between posets and [[(strict) categories]] is outlined
in the module [`Order.Cat`](Order.Cat.html). Very similarly to
categories, posets have a duality involution. In fact, under the
correspondence between posets and thin categories, these are the same
construction.

```agda
_^opp : ∀ {ℓ ℓ′} → Poset ℓ ℓ′ → Poset ℓ ℓ′
P ^opp = to-poset ⌞ P ⌟ λ where
    .make-poset.rel x y         → y ≤ x
    .make-poset.thin            → ≤-thin
    .make-poset.id              → ≤-refl
    .make-poset.trans f<g g<h   → ≤-trans g<h f<g
    .make-poset.antisym f<g g<f → ≤-antisym g<f f<g
  where open Poset P
```
